AWSTemplateFormatVersion: '2010-09-09'
Description: CloudFormation template for ODCR multi-agent system with a
  supervisor agent and two specialized sub-agents

Parameters:
  FoundationModel:
    Type: String
    Description: Continent prefix for Bedrock Foundation Model (e.g., us, apac, eu)
    AllowedValues:
      - anthropic.claude-3-5-haiku-20241022-v1:0
    Default: anthropic.claude-3-5-haiku-20241022-v1:0

  InferenceModel:
    Type: String
    Description: Continent prefix for Bedrock Foundation Model (e.g., us, apac, eu)
    AllowedValues:
      - us.anthropic.claude-3-5-haiku-20241022-v1:0
    Default: us.anthropic.claude-3-5-haiku-20241022-v1:0

  UserEmail:
    Type: String
    Description: Email address for the ODCR user. Must be a valid email address
    AllowedPattern: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
    ConstraintDescription: Must be a valid email address

  ODCRResourceExplorerView:
    Type: String
    MinLength: 1
    Description: This value cannot be empty. ARN of the Resource Explorer view that
      spans all relevant accounts

  CrossAccountRoleName:
    Type: String
    Default: CrossAccountODCRAccessRole
    Description: Name of the IAM role to assume in other accounts for ODCR access

Resources:
  # First: IAM Roles
  GetAZMappingFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: GetAZMappingFunctionRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: GetAZMappingInlinePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sts:AssumeRole
                Resource:
                  - !Sub arn:aws:iam::*:role/${CrossAccountRoleName}
              - Effect: Allow
                Action:
                  - ec2:DescribeAvailabilityZones
                  - sts:GetCallerIdentity
                Resource: '*'
              - Effect: Allow
                Action: logs:CreateLogGroup
                Resource: !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*

  LambdaODCRAccessRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: LambdaODCRAccessRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ODCRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeCapacityReservations
                  - ec2:DescribeAvailabilityZones
                  - resource-explorer-2:Search
                  - resource-explorer-2:ListViews
                  - resource-explorer-2:GetView
                  - sts:AssumeRole
                Resource: '*'
              - Effect: Allow
                Action: logs:CreateLogGroup
                Resource: !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*
              # - Effect: Allow
              #   Action: sts:AssumeRole
              #   Resource: !Sub 'arn:aws:iam::*:role/${CrossAccountRoleName}'
  BedrockAgentExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: BedrockAgentCustomPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeAgent
                  - bedrock:ListFoundationModels
                  - bedrock:GetFoundationModel
                  - bedrock:CreateAgent
                  - bedrock:GetAgent
                  - bedrock:DeleteAgent
                  - bedrock:UpdateAgent
                  - bedrock:CreateAgentAlias
                  - bedrock:DeleteAgentAlias
                  - bedrock:UpdateAgentAlias
                  - bedrock:AssociateAgentCollaborator
                  - bedrock:DisassociateAgentCollaborator
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:GetInferenceProfile
                  - lambda:InvokeFunction
                Resource:
                  - !Sub arn:${AWS::Partition}:bedrock:*::foundation-model/${FoundationModel}
                  - !Sub arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/${InferenceModel}
                  - !Sub arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*
                  - !Sub arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/*
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*

  ODCRSupervisorAgentExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ODCRSupervisorAgentPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: AmazonBedrockAgentsODCRSupervisorAgentPolicy
                Effect: Allow
                Action:
                  - bedrock:GetAgentAlias
                  - bedrock:InvokeAgent
                  - bedrock:InvokeModel
                  - bedrock:ListFoundationModels
                  - bedrock:GetFoundationModel
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:GetInferenceProfile
                Resource:
                  - !Sub arn:${AWS::Partition}:bedrock:*::foundation-model/${FoundationModel}
                  - !Sub arn:${AWS::Partition}:bedrock:${AWS::Region}:${AWS::AccountId}:inference-profile/${InferenceModel}
                  - !GetAtt CapacityPlanningAgentAlias.AgentAliasArn
                  - !GetAtt AugmentationAgentAlias.AgentAliasArn

  # Second: Lambda Functions
  GetAZMappingFunction:
    Type: AWS::Lambda::Function
    DependsOn: GetAZMappingFunctionRole
    Properties:
      FunctionName: get_az_mapping_info
      Handler: index.lambda_handler
      Role: !GetAtt GetAZMappingFunctionRole.Arn
      Runtime: python3.13
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import traceback
          import json
          import botocore
          import os
          import logging

          # Basic logging setup - this one line is all you need to start
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

          # Create logger
          logger = logging.getLogger(__name__)

          def assume_role(account_id, region):
              """
              Assumes an IAM role in the specified AWS account and returns an EC2 client.

              :param account_id: AWS account number
              :param region: AWS region
              :return: Boto3 EC2 client
              """
              try:
                  # Log info message
                  logger.info(f"Attempting to assume role in account {account_id}")

                  sts_client = boto3.client("sts")
                  role_name = os.environ['CROSS_ACCOUNT_ROLE_NAME']
                  role_arn = f"arn:aws:iam::{account_id}:role/{role_name}"
                  assumed_role = sts_client.assume_role(
                      RoleArn=role_arn,
                      RoleSessionName="AssumedODCRSession"
                  )

                  credentials = assumed_role["Credentials"]

                  return boto3.client(
                      "ec2", region_name=region,
                      aws_access_key_id=credentials["AccessKeyId"],
                      aws_secret_access_key=credentials["SecretAccessKey"],
                      aws_session_token=credentials["SessionToken"]
                  )
              except Exception as e:
                  # Log error
                  logger.error(f"Failed to assume role: {str(e)}")        
                  logger.error(f"Failed to assume role in account {account_id}. Please check the account ID is correct and have right permissions.")
                  return f"Unexpected error assuming role in account {account_id}: {str(e)}. Please check the account ID is correct and have right permissions."

          def lambda_handler(event, context):
              """
              AWS Lambda handler to get all Availability Zone IDs for a given AWS account number and region.

              :param event: Dictionary containing 'account_number' and 'region'
              :param context: AWS Lambda context object
              :return: List of Availability Zone IDs or an error message
              """
              try:
                  parameters = event.get("parameters", [])
                  region = None
                  account_number = None

                  # Extract region and account number from event
                  for param in parameters:
                      if param.get("name") == "region":
                          region = param.get("value")
                      elif param.get("name") == "account":
                          account_number = param.get("value")

                  if not region or not account_number:
                      raise ValueError("Missing 'region' or 'account' parameter in event.")

                  # Get the current AWS account ID
                  sts_client = boto3.client("sts")
                  caller_identity = sts_client.get_caller_identity()
                  current_account_id = caller_identity["Account"]

                  # Assume role if needed
                  if account_number != current_account_id:
                      ec2_client = assume_role(account_number, region)
                      if isinstance(ec2_client, str):  # This means an error occurred
                          response_body = {
                              'TEXT': {
                                  'body': ec2_client
                              }
                          }
                          return {
                              'messageVersion': '1.0',
                              'response': {
                                  'actionGroup': event['actionGroup'],
                                  'function': event['function'],
                                  'functionResponse': {
                                      'responseBody': response_body
                                  }
                              },
                              'sessionAttributes': event['sessionAttributes'],
                              'promptSessionAttributes': event['promptSessionAttributes']
                          }
                  else:
                      ec2_client = boto3.client("ec2", region_name=region)

                  # Fetch availability zones
                  try:
                      response = ec2_client.describe_availability_zones()

                      az_ids = {}
                      availability_zones = response.get("AvailabilityZones", [])

                      if availability_zones:
                          for az in availability_zones:
                              zone_name = az.get("ZoneName")
                              zone_id = az.get("ZoneId")
                              if zone_name and zone_id:
                                  az_ids[zone_name] = zone_id
                      else:
                          logger.info("Warning: No availability zones found in the response.")

                      # Prepare the response in the desired format
                      if not az_ids:
                          response_body = {
                              'TEXT': {
                                  'body': 'No Availability Zones found'
                              }
                          }
                      else:
                          response_body = {
                              'TEXT': {
                                  'body': json.dumps(az_ids)  # Convert AZ IDs list to JSON string
                              }
                          }

                  except Exception as e:
                      logger.error(f"Error fetching availability zones: {str(e)}")
                      response_body = {
                          'TEXT': {
                              'body': f"Error fetching availability zones: {str(e)}"
                          }
                      }

                  function_response = {
                      'actionGroup': event['actionGroup'],
                      'function': event['function'],
                      'functionResponse': {
                          'responseBody': response_body
                      }
                  }

                  action_response = {
                      'messageVersion': '1.0',
                      'response': function_response,
                      'sessionAttributes': event['sessionAttributes'],
                      'promptSessionAttributes': event['promptSessionAttributes']
                  }

                  return action_response

              except ValueError as ve:
                  logger.error(f"Validation Error: {str(ve)}")
                  response_body = {
                      'TEXT': {
                          'body': str(ve)
                      }
                  }
                  function_response = {
                      'actionGroup': event['actionGroup'],
                      'function': event['function'],
                      'functionResponse': {
                          'responseBody': response_body
                      }
                  }
                  action_response = {
                      'messageVersion': '1.0',
                      'response': function_response,
                      'sessionAttributes': event['sessionAttributes'],
                      'promptSessionAttributes': event['promptSessionAttributes']
                  }
                  return action_response
              except Exception as e:
                  logger.error(f"Unexpected Error: {str(e)}")
                  traceback.print_exc()
                  response_body = {
                      'TEXT': {
                          'body': f'An unexpected error occurred: {str(e)}'
                      }
                  }
                  function_response = {
                      'actionGroup': event['actionGroup'],
                      'function': event['function'],
                      'functionResponse': {
                          'responseBody': response_body
                      }
                  }
                  action_response = {
                      'messageVersion': '1.0',
                      'response': function_response,
                      'sessionAttributes': event['sessionAttributes'],
                      'promptSessionAttributes': event['promptSessionAttributes']
                  }
                  return action_response
      Environment:
        Variables:
          CROSS_ACCOUNT_ROLE_NAME: !Ref CrossAccountRoleName

  FindEligibleODCRsFunction:
    Type: AWS::Lambda::Function
    DependsOn: LambdaODCRAccessRole
    Properties:
      FunctionName: find_eligible_odcrs
      Handler: index.lambda_handler
      Role: !GetAtt LambdaODCRAccessRole.Arn
      Runtime: python3.13
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import json
          import re
          import os
          import logging

          # Basic logging setup - this one line is all you need to start
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

          # Create logger
          logger = logging.getLogger(__name__)

          def get_odcr_list(resource_explorer_client):
              try:
                  view_arn = os.environ['RESOURCE_EXPLORER_VIEW_ARN']
                  paginator = resource_explorer_client.get_paginator('list_resources')

                  page_iterator = paginator.paginate(
                      Filters={
                          'FilterString': 'resourcetype:ec2:capacity-reservation'
                      },
                      ViewArn=view_arn,
                      MaxResults=20,
                  )
                  

                  print(f"page_iterator: {page_iterator}")
                  all_resources = []

                  for page in page_iterator:
                      resources = page.get("Resources", [])
                      all_resources.extend(resources)

                  print(f"all_resources: {all_resources}")

                  return {"Resources": all_resources}

              except Exception as e:
                  logger.error(f"Error retrieving ODCR details: {e}")
                  return {"Resources": []}

          def parse_arn(arn):
              match = re.match(r"arn:aws:ec2:(?P<region>[a-z0-9-]+):(?P<account_id>[0-9]+):capacity-reservation/(?P<reservation_id>[a-z0-9-]+)", arn)
              if match:
                  return match.groupdict()
              return None

          def assume_role(account_id, region):
              """
              Assumes an IAM role in the specified AWS account and returns an EC2 client.

              :param account_id: AWS account number
              :param region: AWS region
              :return: Boto3 EC2 client
              """
              try:
                  # Log info message
                  logger.info(f"Attempting to assume role in account {account_id}")

                  sts_client = boto3.client("sts")
                  role_name = os.environ['CROSS_ACCOUNT_ROLE_NAME']
                  role_arn = f"arn:aws:iam::{account_id}:role/{role_name}"
                  assumed_role = sts_client.assume_role(
                      RoleArn=role_arn,
                      RoleSessionName="AssumedODCRSession"
                  )

                  credentials = assumed_role["Credentials"]

                  return boto3.client(
                      "ec2", region_name=region,
                      aws_access_key_id=credentials["AccessKeyId"],
                      aws_secret_access_key=credentials["SecretAccessKey"],
                      aws_session_token=credentials["SessionToken"]
                  )
              except Exception as e:
                  # Log error
                  logger.error(f"Failed to assume role: {str(e)}")        
                  logger.error(f"Failed to assume role in account {account_id}. Please check the account ID is correct and have right permissions.")
                  return f"Unexpected error assuming role in account {account_id}: {str(e)}. Please check the account ID is correct and have right permissions."

          def process_arn(region, account_id, reservation_id,mappedazid,InstanceType):
              sts_client = boto3.client("sts")
              caller_identity = sts_client.get_caller_identity()
              current_account_id = caller_identity["Account"]

              if account_id != current_account_id:
                  ec2_client = assume_role(account_id, region)
              else:
                  ec2_client = boto3.client("ec2", region_name=region)

              try:
                  response = ec2_client.describe_capacity_reservations(
                      CapacityReservationIds=[reservation_id],
                      Filters=[
                          {
                              'Name': 'instance-type',
                              'Values': [InstanceType]
                          }
                      ]
                  )

                  if "CapacityReservations" in response and response["CapacityReservations"]:
                      reservation = response["CapacityReservations"][0]

                      if mappedazid is not None:
                          if reservation["AvailabilityZoneId"] == mappedazid and reservation["State"] == 'active' and reservation["AvailableInstanceCount"] !=0:
                              if reservation["EndDateType"] =='unlimited':
                                  endDate = 'unlimited'
                              else:
                                  endDate = reservation["EndDate"].isoformat()

                              available = reservation["AvailableInstanceCount"]
                              total = reservation["TotalInstanceCount"]


                              # Determine splittable capacity
                              if total == available:
                                  splittable_capacity = max(available - 1, 0)
                                  Moveable_capacity = available
                                  split_preference = 'N'
                              else:
                                  splittable_capacity = available
                                  Moveable_capacity = available
                                  split_preference = 'Y'


                              odcr_info = {
                                  "ReservationId": reservation["CapacityReservationId"],
                                  "InstanceType": reservation["InstanceType"],
                                  "AvailabilityZone": reservation["AvailabilityZone"],
                                  "TotalInstanceCount": reservation["TotalInstanceCount"],
                                  "AvailableInstanceCount": reservation["AvailableInstanceCount"],
                                  "InstancePlatform": reservation["InstancePlatform"],
                                  "AvailabilityZoneId": reservation["AvailabilityZoneId"],
                                  "State": reservation["State"],
                                  "Tenancy": reservation["Tenancy"],
                                  "StartDate": reservation["StartDate"].isoformat(),  # Convert datetime to ISO format string
                                  "EndDate": endDate,  # Convert datetime to ISO format string
                                  "Account_ID": account_id,
                                  "Region": region,
                                  "splittableCapacity": splittable_capacity,
                                  "MoveableCapacity": Moveable_capacity,
                                  "SplitPreference": split_preference
                              }
                              return odcr_info
                  else:
                      logger.warning(f"No Capacity Reservation found for {reservation_id}")
                      return None
              except Exception as e:
                  logger.error(f"Error retrieving reservation {reservation_id}: {str(e)}")
                  return None



          def lambda_handler(event, context):
              try:
                  parameters = event.get("parameters", [])

                  arn_details = []
                  odcr_details = []

                  requested_capacity = None
                  mappedazid = None
                  requested_account_number = None
                  InstanceType = None

                  resource_explorer_client = boto3.client('resource-explorer-2')
                  # response = resource_explorer_client.list_views(
                  #     MaxResults=10
                  # )

                  # Get ODCR details
                  odcr_arn_list = get_odcr_list(resource_explorer_client)

                  arn_details = []
                  for resource in odcr_arn_list.get("Resources", []):
                      arn = resource.get("Arn")
                      if arn:
                          parsed_arn = parse_arn(arn)
                          if parsed_arn:
                              arn_details.append(parsed_arn)



                  for param in parameters:
                      if param["name"] == "InstanceType":
                          InstanceType = param["value"]
                      elif param["name"] == "requestedCapacity":
                          requested_capacity = int(param["value"])
                      elif param["name"] == "mappedazid":
                          mappedazid = param["value"]
                      elif param["name"] == "AccountNumber":
                          requested_account_number = param["value"]

                  # Process each ARN after generating output_json
                  for arn_data in arn_details:
                      odcr_info = process_arn(arn_data["region"], arn_data["account_id"], arn_data["reservation_id"],mappedazid,InstanceType)
                      if odcr_info:
                          odcr_details.append(odcr_info)

                  requested_account_odcrs = []
                  other_accounts_odcrs = []

                  for odcr in odcr_details:
                      if odcr["Account_ID"] == requested_account_number:
                          requested_account_odcrs.append(odcr)
                      else:
                          other_accounts_odcrs.append(odcr)

                  requested_account_total_available_capacity = sum(odcr["AvailableInstanceCount"] for odcr in requested_account_odcrs)

                  if requested_account_total_available_capacity >= requested_capacity:
                      final_odcrs = requested_account_odcrs

                  else:
                      # Try to find one other account that can fulfill request alone
                      # Below code will create a list of ODCR at account level, like Account number followed by ODCR IDs for that account.
                      accounts = {}
                      for odcr in other_accounts_odcrs:
                          acc_id = odcr["Account_ID"]
                          accounts.setdefault(acc_id, []).append(odcr)


                      best_fit_account_id = None
                      max_available_capacity = 0
                      final_odcrs = []

                      for account_id, odcrs in accounts.items():
                          total_capacity = sum(o["AvailableInstanceCount"] for o in odcrs)

                          if total_capacity >= requested_capacity and total_capacity > max_available_capacity:
                              best_fit_account_id = account_id
                              final_odcrs = odcrs
                              max_available_capacity = total_capacity

                      if best_fit_account_id:
                          logger.info(f"Requested account lacks capacity. Using ODCRs from account {best_fit_account_id} with {max_available_capacity} capacity.")
                          logger.info(f"Using ODCRs from alternate account {best_fit_account_id}")
                      else:
                          final_odcrs = []
                          logger.info("No account has enough available capacity to fulfill the request.")


                  if not final_odcrs:
                      response_body = {
                          'TEXT': {
                              'body': f"Note: Total available capacity in the requested account ({requested_account_number}) is {requested_account_total_available_capacity}, which is less than the requested capacity of {requested_capacity}."
                          }
                      }
                  else:
                      response_body = {
                          'TEXT': {
                              'body': json.dumps(final_odcrs)
                          }
                      }
                  function_response = {
                      'actionGroup': event['actionGroup'],
                      'function': event['function'],
                      'functionResponse': {
                          'responseBody': response_body
                      }
                  }
                  session_attributes = event['sessionAttributes']
                  prompt_session_attributes = event['promptSessionAttributes']

                  action_response = {
                      'messageVersion': '1.0',
                      'response': function_response,
                      'sessionAttributes': session_attributes,
                      'promptSessionAttributes': prompt_session_attributes
                  }


                  return action_response

              except Exception as e:

                  response_body = {
                    'TEXT': {
                        'body': str(e)
                      }
                  }

                  function_response = {
                      'actionGroup': event['actionGroup'],
                      'function': event['function'],
                      'functionResponse': {
                          'responseBody': response_body
                      }
                  }

                  session_attributes = event['sessionAttributes']
                  prompt_session_attributes = event['promptSessionAttributes']

                  action_response = {
                      'messageVersion': '1.0',
                      'response': function_response,
                      'sessionAttributes': session_attributes,
                      'promptSessionAttributes': prompt_session_attributes
                  }

                  return action_response
      Environment:
        Variables:
          RESOURCE_EXPLORER_VIEW_ARN: !Ref ODCRResourceExplorerView
          CROSS_ACCOUNT_ROLE_NAME: !Ref CrossAccountRoleName

  FindODCRMoveableCapacity:
    Type: AWS::Lambda::Function
    DependsOn: LambdaODCRAccessRole
    Properties:
      FunctionName: find_eligible_odcrs_for_move
      Handler: index.lambda_handler
      Role: !GetAtt LambdaODCRAccessRole.Arn
      Runtime: python3.13
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import json
          import re
          import os
          import logging

          # Basic logging setup - this one line is all you need to start
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

          # Create logger
          logger = logging.getLogger(__name__)

          def get_odcr_list(resource_explorer_client):
              try:
                  view_arn = os.environ['RESOURCE_EXPLORER_VIEW_ARN']
                  paginator = resource_explorer_client.get_paginator('list_resources')

                  page_iterator = paginator.paginate(
                      Filters={
                          'FilterString': 'resourcetype:ec2:capacity-reservation'
                      },
                      ViewArn=view_arn,
                      MaxResults=20,
                  )
                  
                  print(f"page_iterator: {page_iterator}")
                  all_resources = []

                  for page in page_iterator:
                      resources = page.get("Resources", [])
                      all_resources.extend(resources)

                  print(f"all_resources: {all_resources}")

                  return {"Resources": all_resources}

              except Exception as e:
                  logger.error(f"Error retrieving ODCR details: {e}")
                  return {"Resources": []}        

          def parse_arn(arn):
              match = re.match(r"arn:aws:ec2:(?P<region>[a-z0-9-]+):(?P<account_id>[0-9]+):capacity-reservation/(?P<reservation_id>[a-z0-9-]+)", arn)
              if match:
                  return match.groupdict()
              return None

          def assume_role(account_id, region):
              """
              Assumes an IAM role in the specified AWS account and returns an EC2 client.

              :param account_id: AWS account number
              :param region: AWS region
              :return: Boto3 EC2 client
              """
              try:
                  # Log info message
                  logger.info(f"Attempting to assume role in account {account_id}")

                  sts_client = boto3.client("sts")
                  role_name = os.environ['CROSS_ACCOUNT_ROLE_NAME']
                  role_arn = f"arn:aws:iam::{account_id}:role/{role_name}"
                  assumed_role = sts_client.assume_role(
                      RoleArn=role_arn,
                      RoleSessionName="AssumedODCRSession"
                  )

                  credentials = assumed_role["Credentials"]

                  return boto3.client(
                      "ec2", region_name=region,
                      aws_access_key_id=credentials["AccessKeyId"],
                      aws_secret_access_key=credentials["SecretAccessKey"],
                      aws_session_token=credentials["SessionToken"]
                  )
              except Exception as e:
                  # Log error
                  logger.error(f"Failed to assume role: {str(e)}")        
                  logger.error(f"Failed to assume role in account {account_id}. Please check the account ID is correct and have right permissions.")
                  return f"Unexpected error assuming role in account {account_id}: {str(e)}. Please check the account ID is correct and have right permissions."

          def get_odcr_details(requested_odcr_id, requested_account_number, region):

              sts_client = boto3.client("sts")
              caller_identity = sts_client.get_caller_identity()
              current_account_id = caller_identity["Account"]


              if requested_account_number != current_account_id:
                  ec2_client = assume_role(requested_account_number, region)
              else:
                  ec2_client = boto3.client("ec2", region_name=region)

              odcr_info = []
              try:
                  response = ec2_client.describe_capacity_reservations(
                      CapacityReservationIds=[requested_odcr_id]
                  )
                  if "CapacityReservations" in response and response["CapacityReservations"]:
                      reservation = response["CapacityReservations"][0]

                      if reservation["EndDateType"] =='unlimited':
                          endDate = 'unlimited'
                      else:
                          endDate = reservation["EndDate"].isoformat()

                      odcr_info = {
                          "ReservationId": reservation["CapacityReservationId"],
                          "InstanceType": reservation["InstanceType"],
                          "AvailabilityZone": reservation["AvailabilityZone"],
                          "TotalInstanceCount": reservation["TotalInstanceCount"],
                          "AvailableInstanceCount": reservation["AvailableInstanceCount"],
                          "InstancePlatform": reservation["InstancePlatform"],
                          "AvailabilityZoneId": reservation["AvailabilityZoneId"],
                          "State": reservation["State"],
                          "Tenancy": reservation["Tenancy"],
                          "StartDate": reservation["StartDate"].isoformat(),  # Convert datetime to ISO format string
                          "EndDate": endDate  # Convert datetime to ISO format string
                      }

                  return odcr_info

              except Exception as e:
                  logger.error(f"Error retrieving reservation {requested_odcr_id}: {str(e)}")
                  return None


          def process_arn(odcr_id, requested_account_number, requested_region, requested_az_id, requested_instance_type, requested_tenancy):
              sts_client = boto3.client("sts")
              caller_identity = sts_client.get_caller_identity()
              current_account_id = caller_identity["Account"]

              if requested_account_number != current_account_id:
                  ec2_client = assume_role(requested_account_number, requested_region)
              else:
                  ec2_client = boto3.client("ec2", region_name=requested_region)

              try:
                  response = ec2_client.describe_capacity_reservations(
                      CapacityReservationIds=[odcr_id]
                  )

                  if "CapacityReservations" in response and response["CapacityReservations"]:
                      reservation = response["CapacityReservations"][0]
                      if (reservation["State"] == 'active' and
                          reservation["AvailableInstanceCount"] != 0 and
                          reservation["Tenancy"] == requested_tenancy and
                          reservation["AvailabilityZoneId"] == requested_az_id and
                          reservation["InstanceType"] == requested_instance_type):
                          if reservation["EndDateType"] =='unlimited':
                              endDate = 'unlimited'
                          else:
                              endDate = reservation["EndDate"].isoformat()

                          odcr_info = {
                              "ReservationId": reservation["CapacityReservationId"],
                              "InstanceType": reservation["InstanceType"],
                              "AvailabilityZone": reservation["AvailabilityZone"],
                              "TotalInstanceCount": reservation["TotalInstanceCount"],
                              "AvailableInstanceCount": reservation["AvailableInstanceCount"],
                              "InstancePlatform": reservation["InstancePlatform"],
                              "AvailabilityZoneId": reservation["AvailabilityZoneId"],
                              "State": reservation["State"],
                              "Tenancy": reservation["Tenancy"],
                              "StartDate": reservation["StartDate"].isoformat(),  # Convert datetime to ISO format string
                              "EndDate": endDate,  # Convert datetime to ISO format string
                              "MoveableCapacity": reservation["AvailableInstanceCount"]
                          }
                          return odcr_info
                  else:
                      logger.warning(f"No Capacity Reservation found for {odcr_id}")
                      return None
              except Exception as e:
                  logger.error(f"Error retrieving reservation {odcr_id}: {str(e)}")
                  return None


          def lambda_handler(event, context):
              try:

                  parameters = event.get("parameters", [])
                  requested_odcr_id = None


                  resource_explorer_client = boto3.client('resource-explorer-2')
                  # response = resource_explorer_client.list_views(
                  #     MaxResults=10
                  # )
                  # Get ODCR details
                  odcr_arn_list = get_odcr_list(resource_explorer_client)

                  arn_details = []
                  for resource in odcr_arn_list.get("Resources", []):
                      arn = resource.get("Arn")
                      if arn:
                          parsed_arn = parse_arn(arn)
                          if parsed_arn:
                              arn_details.append(parsed_arn)


                  for param in parameters:
                      if param["name"] == "ODCRID":
                          requested_odcr_id = param["value"]

                  requested_odcr_found = 'N'
                  odcr_details = []
                  # let's get Requested ODCR ID details like Account, Region, AZMapped ID etc.
                  for arn_data in arn_details:
                      if arn_data["reservation_id"] == requested_odcr_id:
                          requested_odcr_info = get_odcr_details(requested_odcr_id, arn_data["account_id"], arn_data["region"])
                          if requested_odcr_info:
                              requested_account_number = arn_data["account_id"]
                              requested_region = arn_data["region"]
                              requested_az_id = requested_odcr_info["AvailabilityZoneId"]
                              requested_instance_type = requested_odcr_info["InstanceType"]
                              requested_tenancy = requested_odcr_info["Tenancy"]
                              requested_odcr_found = 'Y'
                              break

                  if requested_odcr_found == 'Y':
                      # Get details about requested ODCR ID
                      for arn_data in arn_details:
                          if requested_account_number == arn_data["account_id"] and requested_region == arn_data["region"] and arn_data["reservation_id"] != requested_odcr_id:
                              odcr_info = process_arn(arn_data["reservation_id"], requested_account_number, requested_region, requested_az_id, requested_instance_type, requested_tenancy)
                              if odcr_info:
                                  odcr_details.append(odcr_info)

                      if not odcr_details:
                          response_body = {
                              'TEXT': {
                                  'body': f"Note: There are no ODCRs available to satisfy the request in the same account where this ODCR ID ({requested_odcr_id}) exist."
                              }
                          }
                      else:
                          response_body = {
                              'TEXT': {
                                  'body': json.dumps(odcr_details)
                              }
                          }
                  else:
                          response_body = {
                              'TEXT': {
                                  'body': f"Note: Requested ODCR ({requested_odcr_id}) doesn not exist."
                              }
                          }

                  function_response = {
                      'actionGroup': event['actionGroup'],
                      'function': event['function'],
                      'functionResponse': {
                          'responseBody': response_body
                      }
                  }
                  session_attributes = event['sessionAttributes']
                  prompt_session_attributes = event['promptSessionAttributes']

                  action_response = {
                      'messageVersion': '1.0',
                      'response': function_response,
                      'sessionAttributes': session_attributes,
                      'promptSessionAttributes': prompt_session_attributes
                  }


                  return action_response

              except Exception as e:

                  response_body = {
                    'TEXT': {
                        'body': str(e)
                      }
                  }

                  function_response = {
                      'actionGroup': event['actionGroup'],
                      'function': event['function'],
                      'functionResponse': {
                          'responseBody': response_body
                      }
                  }

                  session_attributes = event['sessionAttributes']
                  prompt_session_attributes = event['promptSessionAttributes']

                  action_response = {
                      'messageVersion': '1.0',
                      'response': function_response,
                      'sessionAttributes': session_attributes,
                      'promptSessionAttributes': prompt_session_attributes
                  }

                  return action_response
      Environment:
        Variables:
          RESOURCE_EXPLORER_VIEW_ARN: !Ref ODCRResourceExplorerView
          CROSS_ACCOUNT_ROLE_NAME: !Ref CrossAccountRoleName

  # Lambda Permissions
  GetAZMappingPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - GetAZMappingFunction
      - CapacityPlanningAgent
    Properties:
      FunctionName: !Ref GetAZMappingFunction
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${CapacityPlanningAgent}

  FindEligibleODCRsFunctionPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - FindEligibleODCRsFunction
      - CapacityPlanningAgent
    Properties:
      FunctionName: !Ref FindEligibleODCRsFunction
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${CapacityPlanningAgent}

  FindODCRMoveableCapacityPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - FindODCRMoveableCapacity
      - AugmentationAgent
    Properties:
      FunctionName: !Ref FindODCRMoveableCapacity
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/${AugmentationAgent}

  # Agent Configurations
  CapacityPlanningAgent:
    Type: AWS::Bedrock::Agent
    DependsOn:
      - BedrockAgentExecutionRole
      - GetAZMappingFunction
      - FindEligibleODCRsFunction
    Properties:
      AgentName: CapacityPlanningAgent
      Description: Agent to handle capacity planning for new workloads
      Instruction: |
        INTRODUCTION
        You are an agent responsible for providing capacity fulfillment recommendations.
        Customer will ask you to provide recommendation on capacity.
        You need to check existing ODCRs across your organization to find which have Available Capacity and recommend customer how they can use those.
        You can Recommend SPLIT or MOVE operations to the customer.
        You can perform only One SPLIT operation per request.
        You can perform multiple MOVE operations to fulfill the requested capacity.
        Never Provide more than requested Capacity.
        From the tools provided ODCR Details Retrieval Tool, you will get list of ODCRs with details. In ODCR details you will get information like how much capacity you can SPLIT or MOVE from that ODCR. You will also get whether you should give preference to that ODCR for SPLIT or not.
        On any ODCR-ID you can either SPLIT or MOVE.
        You can SPLIT equal to or less than splittableCapacity value.
        You can SPLIT maximum splittableCapacity value.
        For MOVE operation always give priority to ODCR which has highest MoveableCapacity value.
        You can MOVE less than or equal to MoveableCapacity value only from any ODCR ID.
        You can do Either SPLIT or MOVE on any ODCR ID.
        You SHOULD NOT perform Both operations (MOVE and SPLIT) on the same ODCR ID.
        Always perform SPLIT as first operation for sure to create a new ODCR and then you can MOVE capaity from other ODCRs.
        If capacity is provided from a different account than requested, Advise user to use RAM to share newly created ODCR with requested account.
        Always recalculate splittableCapacity and MoveableCapacity value after each operation to check remaining capacity.
        Before providing recommendation, double check numbers to make sure can you MOVE or SPLIT the number you are recommending.

        GLOSSARY
        - ODCR: On-Demand Capacity Reservation
        - MOVE: Transfer capacity between ODCRs
        - SPLIT: Divide capacity within an ODCR to create a new ODCR
        - Capacity Types
            - Total Capacity: Maximum reservable instances
            - Available Capacity: Currently unused instances
            - Relationship: Available Capacity â‰¤ Total Capacity
            -   MoveableCapacity: Total capacity which you can MOVE from source ODCR to Target ODCR
            -   splittableCapacity: Total capacity which you can SPLIT from the source ODCR
            -   SplitPreference: Advising to give preference to ODCR for SPLIT operation.

        1. CORE TOOLS AVAILABLE
        - AZ Mapping Tool
        - ODCR Details Retrieval Tool

        2. Operations Constraints:
        - You can peform only ONE operation either SPLIT or MOVE per ODCR ID
        - Must perform SPLIT before any MOVE operations
        - Keep a track of ODCR remaining capacity
        - If ODCR Details Retrieval Tool does not provide ODCR details, check returned message and respond accordingly.
        - SPLIT Operations Constraints:
            - For SPLIT operation always give priority to ODCR which has
                1) SplitPreference indicator set as Y
                2) Highest splittableCapacity value.
            - Mandatory Requirements
                - Must be first operation attempted
                -   Only one SPLIT operation allowed per request
                -   Maxium you can SPLIT splittableCapacity value
                -   DO NOT SPLIT from ODCR with splittableCapacity = 0
        - MOVE Operations Constraints:
            - For MOVE operation always give priority to ODCR which has Highest MoveableCapacity value
            - Mandatory Requirements
                - Always perform after SPLIT operation
                - Restrictions include:
                    * Cannot move within the same ODCR
                    * Can not move from Target ODCR
                    * Only move source ODCR Available Capacity

        3. REPORTING AND RESPONSE FORMAT
        - Capacity Shortfall Handling:
            - If the total available capacity is less than the requested capacity
            - Directly return the tool returned message without attempting to create a recommendation
            - Inform the user about the exact capacity shortage
            - Do not attempt to artificially create or manipulate capacity
        - Structural Requirements:
            - Use "SPLIT" and "MOVE" terminology consistently
            - Follow prescribed format:
                1.  Source ODCR Details
                    * ARN
                    * Current capacity metrics
                    * AZ information
                2.  Required Operations
                    * SPLIT: [splittableCapacity] instances from [Source ODCR] to create a new ODCR
                    * MOVE: [MoveableCapacity] instances to [Target ODCR] to this newly created ODCR
                    * [OPTIONAL]MOVE: [MoveableCapacity] instances to [Target ODCR] to this newly created ODCR
                3.  Target ODCR Details
                    * New/target ODCR specifications
                    * Post-operation capacity states
                    * Validation metrics
      AutoPrepare: true
      AgentResourceRoleArn: !GetAtt BedrockAgentExecutionRole.Arn
      IdleSessionTTLInSeconds: 1800
      FoundationModel: !Sub ${InferenceModel}
      ActionGroups:
        - ActionGroupName: get_az_mapping_info
          Description: Get AZ mapping information
          ActionGroupExecutor:
            Lambda: !GetAtt GetAZMappingFunction.Arn
          FunctionSchema:
            Functions:
              - Description: Get AZ mapping information
                Name: get_az_mapping_info
                Parameters:
                  region:
                    Description: Region for which we need AZ
                    Required: true
                    Type: string
                  account:
                    Description: This is the account for which the user would like to apply the
                      available capacity reservations.
                    Required: true
                    Type: string
                RequireConfirmation: DISABLED
        - ActionGroupName: find_eligible_odcrs
          Description: Find eligible ODCRs for capacity planning
          ActionGroupExecutor:
            Lambda: !GetAtt FindEligibleODCRsFunction.Arn
          FunctionSchema:
            Functions:
              - Description: Find eligible ODCRs
                Name: find_eligible_odcrs
                Parameters:
                  requestedCapacity:
                    Description: User Requested Capacity
                    Required: true
                    Type: number
                  InstanceType:
                    Description: Requested Instance Type
                    Required: true
                    Type: string
                  mappedazid:
                    Description: Mapped AZ ID
                    Required: true
                    Type: string
                  AccountNumber:
                    Description: Requested Account Number
                    Required: true
                    Type: string
                RequireConfirmation: DISABLED

  AugmentationAgent:
    Type: AWS::Bedrock::Agent
    DependsOn:
      - BedrockAgentExecutionRole
      - FindODCRMoveableCapacity
    Properties:
      AgentName: AugmentationAgent
      Description: Agent to handle existing ODCR capacity augmentation
      Instruction: |
        INTRODUCTION
        You are an agent responsible for providing capacity fulfillment recommendations.
        Customer will ask you to provide recommendation on capacity.
        You need to check existing ODCRs across your organization to find which have Available Capacity and recommend customer how they can use those.
        You can perfom only MOVE operations.
        User will provide you ODCR ID where they need additional capacity. That will be your Target ODCR.
        You will use provided tool to get other matching ODCRs which you can use for recommendations.
        This tool will send you back list of ODCR which will have a field MoveableCapacity.
        You can use MoveableCapacity value to see how much capacity you can move from this ODCR to Target ODCR


        GLOSSARY
        - ODCR: On-Demand Capacity Reservation
        - MOVE: Transfer capacity between ODCRs
        - Capacity Types
            - Total Capacity: Maximum reservable instances
            - Available Capacity: Currently unused instances
            - Relationship: Available Capacity â‰¤ Total Capacity
            -   MoveableCapacity: Total capacity which you can MOVE from source ODCR to Target ODCR

        1. CORE TOOLS AVAILABLE
        - ODCR Details Retrieval Tool

        2. Operations Constraints:
        - Keep a track of ODCR remaining capacity
        - If ODCR Details Retrieval Tool does not provide ODCR details, check returned message and respond accordingly.
        - MOVE Operations Constraints:
            - For MOVE operation always give priority to ODCR which has Highest MoveableCapacity value
            - Mandatory Requirements
                - Restrictions include:
                    * Cannot move within the same ODCR
                    * Can not move from Target ODCR
                    * Only move source ODCR Available Capacity

        3. REPORTING AND RESPONSE FORMAT
        - Capacity Shortfall Handling:
            - If the total available capacity is less than the requested capacity
            - Directly return the tool returned message without attempting to create a recommendation
            - Inform the user about the exact capacity shortage
            - Do not attempt to artificially create or manipulate capacity
        - Structural Requirements:
            - Use "MOVE" terminology consistently
            - Follow prescribed format:
                1.  Source ODCR Details
                    * ARN
                    * Current capacity metrics
                    * AZ information
                2.  Required Operations
                    * MOVE: [MoveableCapacity] instances from [Source ODCR] to the [Target ODCR]
                    * [OPTIONAL]MOVE: [MoveableCapacity] instances from [Source ODCR] to the [Target ODCR]
                3.  Target ODCR Details
                    * New/target ODCR specifications
                    * Post-operation capacity states
                    * Validation metrics
      AutoPrepare: true
      AgentResourceRoleArn: !GetAtt BedrockAgentExecutionRole.Arn
      IdleSessionTTLInSeconds: 1800
      FoundationModel: !Sub ${InferenceModel}
      ActionGroups:
        - ActionGroupName: find_eligible_odcrs_for_move
          Description: Find eligible ODCRs for capacity movement
          ActionGroupExecutor:
            Lambda: !GetAtt FindODCRMoveableCapacity.Arn
          FunctionSchema:
            Functions:
              - Description: Find eligible ODCRs for move operation
                Name: get_odcr_details
                Parameters:
                  ODCRID:
                    Description: ODCR ID provided in the input
                    Required: true
                    Type: string
                  requestedCapacity:
                    Description: Requested Capacity from the user input
                    Required: true
                    Type: number
                RequireConfirmation: DISABLED

  ODCRSupervisorAgent:
    Type: AWS::Bedrock::Agent
    DependsOn:
      - CapacityPlanningAgent
      - AugmentationAgent
      - CapacityPlanningAgentAlias
      - AugmentationAgentAlias
      - ODCRSupervisorAgentExecutionRole
    Properties:
      AgentName: ODCRSupervisorAgent
      Description: Supervisor agent for ODCR capacity management
      Instruction: |
        Agent Overview: You are an intelligent multi-agent focused on AWS capacity management that understands how to analyze and respond to ODCR (On-Demand Capacity Reservation) requests. You have been provided 2 sub agents which can help you to get recommendations based on customer questions. Use those and shared recommendations from those sub agent as is to the user. DONOT change the response.

        GLOSSARY:
        - ODCR: On-Demand Capacity Reservation

        REQUEST TYPES:
        a) User need capacity in a specific ODCR ID
        b) User need capacity for a new workload in provided a account and have not provided any ODCR ID

        Provided Sub Agents:
        1. AugmentationAgent - This agents can help you get recommendations for REQUEST TYPE a, where user has provided the ODCR ID.
        2. CapacityPlanningAgent - This agent can help you get recommendations for REQUEST TYPE b, where user has not provided any ODCR ID.

        Verification:
        - Make sure you have ODCR IDs in the response
        - Clearly mentioned from which ODCR and how much capacity needs to be SPLIT
        - Clearly mentioned from which source ODCR capacity needs to be moved to which Target ODCR
        - Verify all calculations

        If you have any other question from the user which doesn't fall in these 2 categroy, then use your own knowledge to answer user.

        Your job is to understand the request and call subagent to get the details and display results.
      AutoPrepare: true
      AgentResourceRoleArn: !GetAtt ODCRSupervisorAgentExecutionRole.Arn
      IdleSessionTTLInSeconds: 1800
      FoundationModel: !Sub ${InferenceModel}
      AgentCollaboration: SUPERVISOR
      AgentCollaborators:
        - AgentDescriptor:
            AliasArn: !GetAtt CapacityPlanningAgentAlias.AgentAliasArn
          CollaborationInstruction: This collaborator will help you to get recommendations
            for user requests where user has not provided the ODCR ID and
            seeking recommendations to get capacity for their new workload by
            providing account ID.
          CollaboratorName: CapacityPlanningAgent
          RelayConversationHistory: TO_COLLABORATOR
        - AgentDescriptor:
            AliasArn: !GetAtt AugmentationAgentAlias.AgentAliasArn
          CollaborationInstruction: This collaborator will help you to get recommendations
            for user requests where user has provided the ODCR ID and seeking
            recommendations to add more capacity to those ODCRs
          CollaboratorName: AugmentationAgent
          RelayConversationHistory: TO_COLLABORATOR

  # Agent Aliases
  CapacityPlanningAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    DependsOn: CapacityPlanningAgent
    Properties:
      AgentId: !Ref CapacityPlanningAgent
      AgentAliasName: !Sub cp_${AWS::Region}
      Description: Agent for capacity planning recommendations

  AugmentationAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    DependsOn: AugmentationAgent
    Properties:
      AgentId: !Ref AugmentationAgent
      AgentAliasName: !Sub aug_${AWS::Region}
      Description: Agent for ODCR capacity augmentation

  ODCRSupervisorAgentAlias:
    Type: AWS::Bedrock::AgentAlias
    DependsOn: ODCRSupervisorAgent
    Properties:
      AgentId: !Ref ODCRSupervisorAgent
      AgentAliasName: Supervisor
      Description: Supervisor agent for ODCR capacity management

  # Cognito Resources
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: ODCRAgentUserPool
      UsernameAttributes: []
      UsernameConfiguration:
        CaseSensitive: false
      AliasAttributes:
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: true
          Required: false
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: true
        InviteMessageTemplate:
          EmailMessage: Your username is {username} and your temporary password is {####}
          EmailSubject: Your ODCR Agent App temporary password
      AutoVerifiedAttributes:
        - email
      EmailConfiguration:
        EmailSendingAccount: COGNITO_DEFAULT

  ODCRGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      GroupName: ODCRAdmins
      UserPoolId: !Ref CognitoUserPool

  ODCRUser:
    Type: AWS::Cognito::UserPoolUser
    Properties:
      UserPoolId: !Ref CognitoUserPool
      Username: !Select
        - 0
        - !Split
          - '@'
          - !Ref UserEmail
      UserAttributes:
        - Name: email
          Value: !Ref UserEmail
      DesiredDeliveryMediums:
        - EMAIL

  ODCRUserGroupAttachment:
    Type: AWS::Cognito::UserPoolUserToGroupAttachment
    Properties:
      GroupName: !Ref ODCRGroup
      Username: !Select
        - 0
        - !Split
          - '@'
          - !Ref UserEmail
      UserPoolId: !Ref CognitoUserPool

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: ODCRAgentApp
      UserPoolId: !Ref CognitoUserPool
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_SRP_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
        - ALLOW_USER_PASSWORD_AUTH

  CognitoIdentityPool:
    Type: AWS::Cognito::IdentityPool
    Properties:
      IdentityPoolName: odcr-identity-pool
      AllowUnauthenticatedIdentities: false
      CognitoIdentityProviders:
        - ClientId: !Ref UserPoolClient
          ProviderName: !GetAtt CognitoUserPool.ProviderName

  CognitoAuthRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Federated: cognito-identity.amazonaws.com
            Action: sts:AssumeRoleWithWebIdentity
            Condition:
              StringEquals:
                cognito-identity.amazonaws.com:aud: !Ref CognitoIdentityPool
              ForAnyValue:StringLike:
                cognito-identity.amazonaws.com:amr: authenticated
      Policies:
        - PolicyName: CognitoAuthorizedPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeAgent
                #Resource: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent-alias/${ODCRSupervisorAgent}/${ODCRSupervisorAgentAlias}
                Resource: !GetAtt ODCRSupervisorAgentAlias.AgentAliasArn
              - Effect: Allow
                Action:
                  - mobileanalytics:PutEvents
                  - cognito-sync:*
                  - cognito-identity:*
                Resource: '*'

  CognitoIdentityPoolRoleAttachment:
    Type: AWS::Cognito::IdentityPoolRoleAttachment
    Properties:
      IdentityPoolId: !Ref CognitoIdentityPool
      Roles:
        authenticated: !GetAtt CognitoAuthRole.Arn

Outputs:
  AWSRegion:
    Description: AWS Region
    Value: !Ref AWS::Region
  BedrockAgentAliasId:
    Description: Amazon Bedrock Agent Alias ID
    Value: !Select
      - 1
      - !Split
        - '|'
        - !Ref ODCRSupervisorAgentAlias
  BedrockAgentId:
    Description: Amazon Bedrock Agent ID
    Value: !Ref ODCRSupervisorAgent
  BedrockAgentName:
    Description: Amazon Bedrock Agent Name
    Value: ODCRAgent
  IdentityPoolId:
    Description: Amazon Cognito Identity Pool ID
    Value: !Ref CognitoIdentityPool
  Username:
    Description: Username for a ODCR user
    Value: !Select
      - 0
      - !Split
        - '@'
        - !Ref UserEmail
  UserPoolClientId:
    Description: Amazon Cognito User Pool Client ID
    Value: !Ref UserPoolClient
  UserPoolId:
    Description: Amazon Cognito User Pool ID
    Value: !Ref CognitoUserPool